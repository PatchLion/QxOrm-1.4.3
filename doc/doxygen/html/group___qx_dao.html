<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QxOrm: QxDao : QxOrm library database communication used by persistence engine (ORM - Object Relational Mapping)</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="logo_qxorm.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">QxOrm
   &#160;<span id="projectnumber">1.4.3</span>
   </div>
   <div id="projectbrief">C++ Object Relational Mapping library</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group___qx_dao.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">QxDao : QxOrm library database communication used by persistence engine (ORM - Object Relational Mapping)</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html" title="qx::dao::detail::IxDao_Helper : helper class to communicate with database">qx::dao::detail::IxDao_Helper</a> : helper class to communicate with database  <a href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_ix_persistable.html">qx::IxPersistable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_ix_persistable.html" title="qx::IxPersistable : common interface (abstract class) for persistents classes using QX_PERSISTABLE_HP...">qx::IxPersistable</a> : common interface (abstract class) for persistents classes using <a class="el" href="_ix_persistable_8h.html#a311d8fc0e6c4fc1c42e43a54f2dc44da">QX_PERSISTABLE_HPP()</a> and <a class="el" href="_ix_persistable_8h.html#a8c17d818d8f1dbf25636a9d0ed2f96bd">QX_PERSISTABLE_CPP()</a> macros  <a href="classqx_1_1_ix_persistable.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_ix_persistable_collection.html">qx::IxPersistableCollection&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_ix_persistable_collection.html#a1d18f71fc2f7ef6587b246033e3322b5">qx::IxPersistableCollection&lt;T&gt;::type</a> : return the collection type used by <a class="el" href="classqx_1_1_ix_persistable.html" title="qx::IxPersistable : common interface (abstract class) for persistents classes using QX_PERSISTABLE_HP...">qx::IxPersistable</a> interface, <a class="el" href="classqx_1_1_qx_collection.html" title="qx::QxCollection&lt;Key, Value&gt; : QxOrm container (keep insertion order + quick access by index + quick ...">qx::QxCollection</a>&lt;type_primary_key, qx_shared_ptr&lt;my_type&gt;&gt;  <a href="classqx_1_1_ix_persistable_collection.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_ix_sql_query_builder.html">qx::IxSqlQueryBuilder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_ix_sql_query_builder.html" title="qx::IxSqlQueryBuilder : common interface to build SQL queries to communicate with database...">qx::IxSqlQueryBuilder</a> : common interface to build SQL queries to communicate with database  <a href="classqx_1_1_ix_sql_query_builder.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_ix_sql_relation.html">qx::IxSqlRelation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_ix_sql_relation.html" title="qx::IxSqlRelation : common interface for all relationships defined between 2 classes (or between 2 ta...">qx::IxSqlRelation</a> : common interface for all relationships defined between 2 classes (or between 2 tables in database)  <a href="classqx_1_1_ix_sql_relation.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqx_1_1dao_1_1detail_1_1_qx_dao_async_params.html">qx::dao::detail::QxDaoAsyncParams</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structqx_1_1dao_1_1detail_1_1_qx_dao_async_params.html" title="qx::dao::detail::QxDaoAsyncParams : all parameters for qx::QxDaoAsync class to execute queries...">qx::dao::detail::QxDaoAsyncParams</a> : all parameters for <a class="el" href="classqx_1_1_qx_dao_async.html" title="qx::QxDaoAsync : helper class to execute SQL queries in another thread (asynchronous way) using qx::I...">qx::QxDaoAsync</a> class to execute queries  <a href="structqx_1_1dao_1_1detail_1_1_qx_dao_async_params.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_dao_async_runner.html">qx::dao::detail::QxDaoAsyncRunner</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_dao_async_runner.html" title="qx::dao::detail::QxDaoAsyncRunner : class with a slot to execute queries in another thread...">qx::dao::detail::QxDaoAsyncRunner</a> : class with a slot to execute queries in another thread  <a href="classqx_1_1dao_1_1detail_1_1_qx_dao_async_runner.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_dao_async.html">qx::QxDaoAsync</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_qx_dao_async.html" title="qx::QxDaoAsync : helper class to execute SQL queries in another thread (asynchronous way) using qx::I...">qx::QxDaoAsync</a> : helper class to execute SQL queries in another thread (asynchronous way) using <a class="el" href="classqx_1_1_ix_persistable.html" title="qx::IxPersistable : common interface (abstract class) for persistents classes using QX_PERSISTABLE_HP...">qx::IxPersistable</a> interface  <a href="classqx_1_1_qx_dao_async.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1ptr.html">qx::dao::ptr&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::dao::ptr&lt;T&gt; : provide a classic smart-pointer (like boost::shared_ptr&lt;T&gt; or QSharedPointer&lt;T&gt;) with some features associated with QxDao module of QxOrm library  <a href="classqx_1_1dao_1_1ptr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqx_1_1dao_1_1strategy.html">qx::dao::strategy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structqx_1_1dao_1_1strategy.html" title="qx::dao::strategy : class inheritance strategy and database (Concrete Table Inheritance is the defaul...">qx::dao::strategy</a> : class inheritance strategy and database (Concrete Table Inheritance is the default strategy used by QxOrm library)  <a href="structqx_1_1dao_1_1strategy.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_date_neutral.html">qx::QxDateNeutral</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_qx_date_neutral.html" title="qx::QxDateNeutral : helper class to store a date value into database under neutral format (YYYYMMDD) ...">qx::QxDateNeutral</a> : helper class to store a date value into database under neutral format (YYYYMMDD) =&gt; cross database compatibility  <a href="classqx_1_1_qx_date_neutral.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_date_time_neutral.html">qx::QxDateTimeNeutral</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_qx_date_time_neutral.html" title="qx::QxDateTimeNeutral : helper class to store a date-time value into database under neutral format (Y...">qx::QxDateTimeNeutral</a> : helper class to store a date-time value into database under neutral format (YYYYMMDDHHMMSS) =&gt; cross database compatibility  <a href="classqx_1_1_qx_date_time_neutral.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_ix_repository.html">qx::IxRepository</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_ix_repository.html" title="qx::IxRepository : common interface for all repositories to provide access to database by introspecti...">qx::IxRepository</a> : common interface for all repositories to provide access to database by introspection using QObject class or <a class="el" href="classqx_1_1_ix_collection.html" title="qx::IxCollection : common interface for all QxOrm containers qx::QxCollection&lt;Key, Value&gt;">qx::IxCollection</a> class  <a href="classqx_1_1_ix_repository.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_repository.html">qx::QxRepository&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxRepository&lt;T&gt; : repository to provide a common interface to communicate with database  <a href="classqx_1_1_qx_repository.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_repository_x.html">qx::QxRepositoryX</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_qx_repository_x.html" title="qx::QxRepositoryX : list of all repositories registered using qx::register_repository&lt;T&gt; function...">qx::QxRepositoryX</a> : list of all repositories registered using <a class="el" href="namespaceqx.html#a10d662c78d56271d8fdaeff896548e46">qx::register_repository&lt;T&gt;</a> function  <a href="classqx_1_1_qx_repository_x.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_session.html">qx::QxSession</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_qx_session.html" title="qx::QxSession : define a session to manage automatically database transactions (using C++ RAII)...">qx::QxSession</a> : define a session to manage automatically database transactions (using C++ RAII)  <a href="classqx_1_1_qx_session.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_soft_delete.html">qx::QxSoftDelete</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_qx_soft_delete.html" title="qx::QxSoftDelete : soft delete (or logical delete) behavior to update a row into database (flag it as...">qx::QxSoftDelete</a> : soft delete (or logical delete) behavior to update a row into database (flag it as deleted) instead of delete it from database  <a href="classqx_1_1_qx_soft_delete.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_database.html">qx::QxSqlDatabase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> : define all parameters to connect to database and retrieve a valid connection by thread (this class is a singleton and is thread-safe)  <a href="classqx_1_1_qx_sql_database.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_sql_element.html">qx::dao::detail::IxSqlElement</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_sql_element.html" title="qx::dao::detail::IxSqlElement : common interface for all SQL elements to build SQL query...">qx::dao::detail::IxSqlElement</a> : common interface for all SQL elements to build SQL query  <a href="classqx_1_1dao_1_1detail_1_1_ix_sql_element.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_compare.html">qx::dao::detail::QxSqlCompare</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_compare.html" title="qx::dao::detail::QxSqlCompare : SQL element to compare value (==, &lt;, &gt;, &lt;=, &gt;=, LIKE, NOT LIKE, etc.)">qx::dao::detail::QxSqlCompare</a> : SQL element to compare value (==, &lt;, &gt;, &lt;=, &gt;=, LIKE, NOT LIKE, etc.)  <a href="classqx_1_1dao_1_1detail_1_1_qx_sql_compare.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_element_temp.html">qx::dao::detail::QxSqlElementTemp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_element_temp.html" title="qx::dao::detail::QxSqlElementTemp : temporary SQL element (need to be cloned to be used)...">qx::dao::detail::QxSqlElementTemp</a> : temporary SQL element (need to be cloned to be used)  <a href="classqx_1_1dao_1_1detail_1_1_qx_sql_element_temp.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_expression.html">qx::dao::detail::QxSqlExpression</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_expression.html" title="qx::dao::detail::QxSqlExpression : SQL element to build a SQL expression (WHERE, AND, OR, etc.)">qx::dao::detail::QxSqlExpression</a> : SQL element to build a SQL expression (WHERE, AND, OR, etc.)  <a href="classqx_1_1dao_1_1detail_1_1_qx_sql_expression.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_free_text.html">qx::dao::detail::QxSqlFreeText</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_free_text.html" title="qx::dao::detail::QxSqlFreeText : possibility to add free text to SQL query">qx::dao::detail::QxSqlFreeText</a> : possibility to add free text to SQL query  <a href="classqx_1_1dao_1_1detail_1_1_qx_sql_free_text.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_in.html">qx::dao::detail::QxSqlIn</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_in.html" title="qx::dao::detail::QxSqlIn : SQL element to verify a list of values (IN, NOT IN, etc.)">qx::dao::detail::QxSqlIn</a> : SQL element to verify a list of values (IN, NOT IN, etc.)  <a href="classqx_1_1dao_1_1detail_1_1_qx_sql_in.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_is_between.html">qx::dao::detail::QxSqlIsBetween</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_is_between.html" title="qx::dao::detail::QxSqlIsBetween : SQL element to verify if a value is included into 2 other values...">qx::dao::detail::QxSqlIsBetween</a> : SQL element to verify if a value is included into 2 other values  <a href="classqx_1_1dao_1_1detail_1_1_qx_sql_is_between.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_is_null.html">qx::dao::detail::QxSqlIsNull</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_is_null.html" title="qx::dao::detail::QxSqlIsNull : SQL element to verify if a value is null or not null (IS NULL...">qx::dao::detail::QxSqlIsNull</a> : SQL element to verify if a value is null or not null (IS NULL, IS NOT NULL)  <a href="classqx_1_1dao_1_1detail_1_1_qx_sql_is_null.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_limit.html">qx::dao::detail::QxSqlLimit</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_limit.html" title="qx::dao::detail::QxSqlLimit : SQL element to limit rows count fetched from database">qx::dao::detail::QxSqlLimit</a> : SQL element to limit rows count fetched from database  <a href="classqx_1_1dao_1_1detail_1_1_qx_sql_limit.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_sort.html">qx::dao::detail::QxSqlSort</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_sort.html" title="qx::dao::detail::QxSqlSort : SQL element to sort or to group list of elements fetched from database (...">qx::dao::detail::QxSqlSort</a> : SQL element to sort or to group list of elements fetched from database (ORDER BY, GROUP BY)  <a href="classqx_1_1dao_1_1detail_1_1_qx_sql_sort.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1sql__error.html">qx::dao::sql_error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1sql__error.html" title="qx::dao::sql_error : define a SQL error exception and retrieve QSqlError type of Qt library...">qx::dao::sql_error</a> : define a SQL error exception and retrieve QSqlError type of Qt library  <a href="classqx_1_1dao_1_1sql__error.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_sql_generator.html">qx::dao::detail::IxSqlGenerator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_sql_generator.html" title="qx::dao::detail::IxSqlGenerator : common interface for all SQL generators to build SQL query specific...">qx::dao::detail::IxSqlGenerator</a> : common interface for all SQL generators to build SQL query specific for each database  <a href="classqx_1_1dao_1_1detail_1_1_ix_sql_generator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___m_s_s_q_l_server.html">qx::dao::detail::QxSqlGenerator_MSSQLServer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___m_s_s_q_l_server.html" title="qx::dao::detail::QxSqlGenerator_MSSQLServer : SQL generator for Microsoft SQL Server database...">qx::dao::detail::QxSqlGenerator_MSSQLServer</a> : SQL generator for Microsoft SQL Server database  <a href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___m_s_s_q_l_server.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___my_s_q_l.html">qx::dao::detail::QxSqlGenerator_MySQL</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___my_s_q_l.html" title="qx::dao::detail::QxSqlGenerator_MySQL : SQL generator for MySQL database">qx::dao::detail::QxSqlGenerator_MySQL</a> : SQL generator for MySQL database  <a href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___my_s_q_l.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___oracle.html">qx::dao::detail::QxSqlGenerator_Oracle</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___oracle.html" title="qx::dao::detail::QxSqlGenerator_Oracle : SQL generator for Oracle database">qx::dao::detail::QxSqlGenerator_Oracle</a> : SQL generator for Oracle database  <a href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___oracle.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___postgre_s_q_l.html">qx::dao::detail::QxSqlGenerator_PostgreSQL</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___postgre_s_q_l.html" title="qx::dao::detail::QxSqlGenerator_PostgreSQL : SQL generator for PostgreSQL database">qx::dao::detail::QxSqlGenerator_PostgreSQL</a> : SQL generator for PostgreSQL database  <a href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___postgre_s_q_l.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___s_q_lite.html">qx::dao::detail::QxSqlGenerator_SQLite</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___s_q_lite.html" title="qx::dao::detail::QxSqlGenerator_SQLite : SQL generator for SQLite database">qx::dao::detail::QxSqlGenerator_SQLite</a> : SQL generator for SQLite database  <a href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___s_q_lite.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___standard.html">qx::dao::detail::QxSqlGenerator_Standard</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___standard.html" title="qx::dao::detail::QxSqlGenerator_Standard : SQL generator to build standard SQL query">qx::dao::detail::QxSqlGenerator_Standard</a> : SQL generator to build standard SQL query  <a href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___standard.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqx_1_1dao_1_1sql__join.html">qx::dao::sql_join</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structqx_1_1dao_1_1sql__join.html" title="qx::dao::sql_join : define how to join 2 tables into SQL query (LEFT OUTER JOIN, INNER JOIN...">qx::dao::sql_join</a> : define how to join 2 tables into SQL query (LEFT OUTER JOIN, INNER JOIN, etc...)  <a href="structqx_1_1dao_1_1sql__join.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_qx_sql_query.html" title="qx::QxSqlQuery : define a user SQL query added to default SQL query builded by QxOrm library...">qx::QxSqlQuery</a> : define a user SQL query added to default SQL query builded by QxOrm library, and used by qx::dao::xxx functions to filter elements fetched from database  <a href="classqx_1_1_qx_sql_query.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_query_builder.html">qx::QxSqlQueryBuilder&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlQueryBuilder&lt;T&gt; : concrete SQL query builder for class T with a cache mechanism to backup and restore queries already built by the program  <a href="classqx_1_1_qx_sql_query_builder.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_query_builder___count.html">qx::QxSqlQueryBuilder_Count&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlQueryBuilder_Count&lt;T&gt; : concrete SQL query builder for class T to build a COUNT SQL query  <a href="classqx_1_1_qx_sql_query_builder___count.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_query_builder___exist.html">qx::QxSqlQueryBuilder_Exist&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlQueryBuilder_Exist&lt;T&gt; : concrete SQL query builder for class T to build an EXIST SQL query  <a href="classqx_1_1_qx_sql_query_builder___exist.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_query_builder___fetch_all.html">qx::QxSqlQueryBuilder_FetchAll&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlQueryBuilder_FetchAll&lt;T&gt; : concrete SQL query builder for class T to build a FETCH ALL SQL query  <a href="classqx_1_1_qx_sql_query_builder___fetch_all.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_query_builder___fetch_by_id.html">qx::QxSqlQueryBuilder_FetchById&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlQueryBuilder_FetchById&lt;T&gt; : concrete SQL query builder for class T to build a FETCH BY ID SQL query  <a href="classqx_1_1_qx_sql_query_builder___fetch_by_id.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_query_builder___insert.html">qx::QxSqlQueryBuilder_Insert&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlQueryBuilder_Insert&lt;T&gt; : concrete SQL query builder for class T to build an INSERT SQL query  <a href="classqx_1_1_qx_sql_query_builder___insert.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_query_builder___update.html">qx::QxSqlQueryBuilder_Update&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlQueryBuilder_Update&lt;T&gt; : concrete SQL query builder for class T to build an UPDATE SQL query  <a href="classqx_1_1_qx_sql_query_builder___update.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_query_builder___delete_all.html">qx::QxSqlQueryBuilder_DeleteAll&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlQueryBuilder_DeleteAll&lt;T&gt; : concrete SQL query builder for class T to build a DELETE ALL SQL query  <a href="classqx_1_1_qx_sql_query_builder___delete_all.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_query_builder___soft_delete_all.html">qx::QxSqlQueryBuilder_SoftDeleteAll&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlQueryBuilder_SoftDeleteAll&lt;T&gt; : concrete SQL query builder for class T to build a SOFT DELETE ALL SQL query  <a href="classqx_1_1_qx_sql_query_builder___soft_delete_all.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_query_builder___delete_by_id.html">qx::QxSqlQueryBuilder_DeleteById&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlQueryBuilder_DeleteById&lt;T&gt; : concrete SQL query builder for class T to build a DELETE BY ID SQL query  <a href="classqx_1_1_qx_sql_query_builder___delete_by_id.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_query_builder___soft_delete_by_id.html">qx::QxSqlQueryBuilder_SoftDeleteById&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlQueryBuilder_SoftDeleteById&lt;T&gt; : concrete SQL query builder for class T to build a SOFT DELETE BY ID SQL query  <a href="classqx_1_1_qx_sql_query_builder___soft_delete_by_id.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_query_builder___create_table.html">qx::QxSqlQueryBuilder_CreateTable&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlQueryBuilder_CreateTable&lt;T&gt; : concrete SQL query builder for class T to build a CREATE TABLE SQL query  <a href="classqx_1_1_qx_sql_query_builder___create_table.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_query_builder___fetch_all___with_relation.html">qx::QxSqlQueryBuilder_FetchAll_WithRelation&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlQueryBuilder_FetchAll_WithRelation&lt;T&gt; : concrete SQL query builder for class T to build a FETCH ALL WITH RELATION SQL query  <a href="classqx_1_1_qx_sql_query_builder___fetch_all___with_relation.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_query_builder___fetch_by_id___with_relation.html">qx::QxSqlQueryBuilder_FetchById_WithRelation&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlQueryBuilder_FetchById_WithRelation&lt;T&gt; : concrete SQL query builder for class T to build a FETCH BY ID WITH RELATION SQL query  <a href="classqx_1_1_qx_sql_query_builder___fetch_by_id___with_relation.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_relation.html">qx::QxSqlRelation&lt; DataType, Owner &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlRelation&lt;DataType, Owner&gt; : base class for all relationships defined between 2 classes (or between 2 tables in database)  <a href="classqx_1_1_qx_sql_relation.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_relation___many_to_many.html">qx::QxSqlRelation_ManyToMany&lt; DataType, Owner &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlRelation_ManyToMany&lt;DataType, Owner&gt; : manage a relationship many-to-many defined between 2 classes (or between 2 tables in database)  <a href="classqx_1_1_qx_sql_relation___many_to_many.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_relation___many_to_one.html">qx::QxSqlRelation_ManyToOne&lt; DataType, Owner &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlRelation_ManyToOne&lt;DataType, Owner&gt; : manage a relationship many-to-one defined between 2 classes (or between 2 tables in database)  <a href="classqx_1_1_qx_sql_relation___many_to_one.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_relation___one_to_many.html">qx::QxSqlRelation_OneToMany&lt; DataType, Owner &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlRelation_OneToMany&lt;DataType, Owner&gt; : manage a relationship one-to-many defined between 2 classes (or between 2 tables in database)  <a href="classqx_1_1_qx_sql_relation___one_to_many.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_relation___one_to_one.html">qx::QxSqlRelation_OneToOne&lt; DataType, Owner &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">qx::QxSqlRelation_OneToOne&lt;DataType, Owner&gt; : manage a relationship one-to-one defined between 2 classes (or between 2 tables in database)  <a href="classqx_1_1_qx_sql_relation___one_to_one.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_relation_linked.html">qx::QxSqlRelationLinked</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_qx_sql_relation_linked.html" title="qx::QxSqlRelationLinked : hierarchy of relationships to build SQL query">qx::QxSqlRelationLinked</a> : hierarchy of relationships to build SQL query  <a href="classqx_1_1_qx_sql_relation_linked.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_sql_relation_params.html">qx::QxSqlRelationParams</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_qx_sql_relation_params.html" title="qx::QxSqlRelationParams : define list of parameters to transfer to relationships to manage SQL querie...">qx::QxSqlRelationParams</a> : define list of parameters to transfer to relationships to manage SQL queries builded by QxOrm library  <a href="classqx_1_1_qx_sql_relation_params.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqx_1_1dao_1_1save__mode.html">qx::dao::save_mode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structqx_1_1dao_1_1save__mode.html" title="qx::dao::save_mode : to improve performance, if you know that you are just inserting or updating item...">qx::dao::save_mode</a> : to improve performance, if you know that you are just inserting or updating items in database  <a href="structqx_1_1dao_1_1save__mode.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqx_1_1_qx_time_neutral.html">qx::QxTimeNeutral</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqx_1_1_qx_time_neutral.html" title="qx::QxTimeNeutral : helper class to store a time value into database under neutral format (HHMMSS) =&gt;...">qx::QxTimeNeutral</a> : helper class to store a time value into database under neutral format (HHMMSS) =&gt; cross database compatibility  <a href="classqx_1_1_qx_time_neutral.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqx_1_1dao.html">qx::dao</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Database communication used by persistence engine (ORM - Object Relational Mapping) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqx_1_1dao_1_1detail.html">qx::dao::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Internal helper tools for <a class="el" href="namespaceqx_1_1dao.html" title="Database communication used by persistence engine (ORM - Object Relational Mapping)">qx::dao</a> namespace. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqx_1_1dao_1_1throwable.html">qx::dao::throwable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Same functions as <a class="el" href="namespaceqx_1_1dao.html" title="Database communication used by persistence engine (ORM - Object Relational Mapping)">qx::dao</a> namespace, but throw a <em><a class="el" href="classqx_1_1dao_1_1sql__error.html" title="qx::dao::sql_error : define a SQL error exception and retrieve QSqlError type of Qt library...">qx::dao::sql_error</a></em> exception when a SQL error occurred (instead of returning a QSqlError instance) </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ix_dao___helper_8h.html">IxDao_Helper.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper class to communicate with database. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ix_persistable_8h.html">IxPersistable.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Common interface (abstract class) for persistents classes using <a class="el" href="_ix_persistable_8h.html#a311d8fc0e6c4fc1c42e43a54f2dc44da">QX_PERSISTABLE_HPP()</a> and <a class="el" href="_ix_persistable_8h.html#a8c17d818d8f1dbf25636a9d0ed2f96bd">QX_PERSISTABLE_CPP()</a> macros. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ix_sql_query_builder_8h.html">IxSqlQueryBuilder.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Common interface to build SQL queries to communicate with database. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ix_sql_relation_8h.html">IxSqlRelation.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Common interface for all relationships defined between 2 classes (or between 2 tables in database) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_dao_8h.html">QxDao.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provide template functions to map C++ class registered into QxOrm context with table database (ORM - Object Relational Mapping) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_dao_async_8h.html">QxDaoAsync.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper class to execute SQL queries in another thread (asynchronous way) using <a class="el" href="classqx_1_1_ix_persistable.html" title="qx::IxPersistable : common interface (abstract class) for persistents classes using QX_PERSISTABLE_HP...">qx::IxPersistable</a> interface. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_dao_pointer_8h.html">QxDaoPointer.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>qx::dao::ptr&lt;T&gt; : provide a classic smart-pointer (like boost::shared_ptr&lt;T&gt; or QSharedPointer&lt;T&gt;) with some features associated with QxDao module of QxOrm library </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_dao_strategy_8h.html">QxDaoStrategy.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Class inheritance strategy and database (Concrete Table Inheritance is the default strategy used by QxOrm library) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_dao_throwable_8h.html">QxDaoThrowable.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Same functions as <a class="el" href="namespaceqx_1_1dao.html" title="Database communication used by persistence engine (ORM - Object Relational Mapping)">qx::dao</a> namespace, but throw a <em><a class="el" href="classqx_1_1dao_1_1sql__error.html" title="qx::dao::sql_error : define a SQL error exception and retrieve QSqlError type of Qt library...">qx::dao::sql_error</a></em> exception when a SQL error occurred (instead of returning a QSqlError instance) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_date_neutral_8h.html">QxDateNeutral.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper class to store a date value into database under neutral format (YYYYMMDD) =&gt; cross database compatibility. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_date_time_neutral_8h.html">QxDateTimeNeutral.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper class to store a date-time value into database under neutral format (YYYYMMDDHHMMSS) =&gt; cross database compatibility. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ix_repository_8h.html">IxRepository.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Common interface for all repositories to provide access to database by introspection using QObject class or <a class="el" href="classqx_1_1_ix_collection.html" title="qx::IxCollection : common interface for all QxOrm containers qx::QxCollection&lt;Key, Value&gt;">qx::IxCollection</a> class. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_repository_8h.html">QxRepository.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Repository to provide a common interface to communicate with database. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_repository_x_8h.html">QxRepositoryX.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>List of all repositories registered using <a class="el" href="namespaceqx.html#a10d662c78d56271d8fdaeff896548e46">qx::register_repository&lt;T&gt;</a> function. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_session_8h.html">QxSession.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Define a session to manage automatically database transactions (using C++ RAII) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_soft_delete_8h.html">QxSoftDelete.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Soft delete (or logical delete) behavior to update a row into database (flag it as deleted) instead of delete it from database. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_database_8h.html">QxSqlDatabase.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Define all parameters to connect to database and retrieve a valid connection by thread. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ix_sql_element_8h.html">IxSqlElement.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Common interface for all SQL elements to build SQL query. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_compare_8h.html">QxSqlCompare.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>SQL element to compare value (==, &lt;, &gt;, &lt;=, &gt;=, LIKE, NOT LIKE, etc.) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_element_temp_8h.html">QxSqlElementTemp.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Temporary SQL element (need to be cloned to be used) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_expression_8h.html">QxSqlExpression.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>SQL element to build a SQL expression (WHERE, AND, OR, etc.) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_free_text_8h.html">QxSqlFreeText.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Possibility to add free text to SQL query. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_in_8h.html">QxSqlIn.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>SQL element to verify a list of values (IN, NOT IN, etc.) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_is_between_8h.html">QxSqlIsBetween.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>SQL element to verify if a value is included into 2 other values. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_is_null_8h.html">QxSqlIsNull.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>SQL element to verify if a value is null or not null (IS NULL, IS NOT NULL) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_limit_8h.html">QxSqlLimit.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>SQL element to limit rows count fetched from database. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_sort_8h.html">QxSqlSort.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>SQL element to sort or to group list of elements fetched from database (ORDER BY, GROUP BY) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_error_8h.html">QxSqlError.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Define a SQL error exception and retrieve QSqlError type of Qt library. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ix_sql_generator_8h.html">IxSqlGenerator.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Common interface for all SQL generators to build SQL query specific for each database. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_generator___m_s_s_q_l_server_8h.html">QxSqlGenerator_MSSQLServer.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>SQL generator for Microsoft SQL Server database. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_generator___my_s_q_l_8h.html">QxSqlGenerator_MySQL.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>SQL generator for MySQL database. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_generator___oracle_8h.html">QxSqlGenerator_Oracle.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>SQL generator for Oracle database. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_generator___postgre_s_q_l_8h.html">QxSqlGenerator_PostgreSQL.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>SQL generator for PostgreSQL database. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_generator___s_q_lite_8h.html">QxSqlGenerator_SQLite.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>SQL generator for SQLite database. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_generator___standard_8h.html">QxSqlGenerator_Standard.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>SQL generator to build standard SQL query. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_join_8h.html">QxSqlJoin.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Define how to join 2 tables into SQL query (LEFT OUTER JOIN, INNER JOIN, etc...) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_query_8h.html">QxSqlQuery.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Define a user SQL query added to default SQL query builded by QxOrm library, and used by qx::dao::xxx functions to filter elements fetched from database. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_query_builder_8h.html">QxSqlQueryBuilder.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Concrete SQL query builder by class with a cache mechanism to backup and restore queries already built by the program. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_relation_8h.html">QxSqlRelation.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Base class for all relationships defined between 2 classes (or between 2 tables in database) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_relation___many_to_many_8h.html">QxSqlRelation_ManyToMany.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Manage a relationship many-to-many defined between 2 classes (or between 2 tables in database) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_relation___many_to_one_8h.html">QxSqlRelation_ManyToOne.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Manage a relationship many-to-one defined between 2 classes (or between 2 tables in database) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_relation___one_to_many_8h.html">QxSqlRelation_OneToMany.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Manage a relationship one-to-many defined between 2 classes (or between 2 tables in database) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_relation___one_to_one_8h.html">QxSqlRelation_OneToOne.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Manage a relationship one-to-one defined between 2 classes (or between 2 tables in database) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_relation_linked_8h.html">QxSqlRelationLinked.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Hierarchy of relationships to build SQL query. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_relation_params_8h.html">QxSqlRelationParams.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Define list of parameters to transfer to relationships to manage SQL queries builded by QxOrm library. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_sql_save_mode_8h.html">QxSqlSaveMode.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>To improve performance, if you know that you are just inserting or updating items in database. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_qx_time_neutral_8h.html">QxTimeNeutral.h</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper class to store a time value into database under neutral format (HHMMSS) =&gt; cross database compatibility. </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gaf777ce33c67ea7fcd4e60b740d15f9ec">qx::dao::count</a> (const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query=<a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a>(), QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of lines in the table (database) mapped to the C++ class T (registered into QxOrm context) and filtered by a user SQL query.  <a href="#gaf777ce33c67ea7fcd4e60b740d15f9ec"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga092ef20c723a13b6250ed27153162665">qx::dao::count</a> (long &amp;lCount, const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query=<a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a>(), QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of lines in the table (database) mapped to the C++ class T (registered into QxOrm context) and filtered by a user SQL query.  <a href="#ga092ef20c723a13b6250ed27153162665"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gab4400decee849f008633c52a47508995">qx::dao::insert</a> (T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element or a list of elements into database.  <a href="#gab4400decee849f008633c52a47508995"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga100e9d635a4720ed9512799ba0ea519b">qx::dao::save</a> (T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert (if no exist) or update (if already exist) an element or a list of elements into database.  <a href="#ga100e9d635a4720ed9512799ba0ea519b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga298e15a5e745ae43d99de9b4279aca3e">qx::dao::delete_by_id</a> (T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a line (or list of lines) of a table (database) mapped to a C++ object of type T (registered into QxOrm context)  <a href="#ga298e15a5e745ae43d99de9b4279aca3e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga776e2edd2da36029cddc13e9e6e366f5">qx::dao::destroy_by_id</a> (T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a line (or list of lines) of a table (database) mapped to a C++ object of type T (registered into QxOrm context), even if a soft delete behavior is defined for class T.  <a href="#ga776e2edd2da36029cddc13e9e6e366f5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga959410c3e4bcc075a7c5f9c5d41bb734">qx::dao::delete_all</a> (QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all lines of a table (database) mapped to a C++ class T (registered into QxOrm context)  <a href="#ga959410c3e4bcc075a7c5f9c5d41bb734"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga075cc9ac81c4cf65fb67d3d286a1de76">qx::dao::destroy_all</a> (QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy all lines of a table (database) mapped to a C++ class T (registered into QxOrm context), even if a soft delete behavior is defined for class T.  <a href="#ga075cc9ac81c4cf65fb67d3d286a1de76"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gac9f35c808cdff54ecd0c06784fffccdf">qx::dao::delete_by_query</a> (const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all lines of a table (database) mapped to a C++ class T (registered into QxOrm context) and filtered by a user SQL query.  <a href="#gac9f35c808cdff54ecd0c06784fffccdf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga859152daecd5f06d8ca7442dc4b719a3">qx::dao::destroy_by_query</a> (const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy all lines of a table (database) mapped to a C++ class T (registered into QxOrm context) and filtered by a user SQL query, even if a soft delete behavior is defined for class T.  <a href="#ga859152daecd5f06d8ca7442dc4b719a3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gacdaac47549d0e850cf5d6a16315efaab">qx::dao::create_table</a> (QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a table into database (with all columns) mapped to a C++ class T (registered into QxOrm context) : be careful, this function can be used only with a SQLite database to create examples or prototypes; For other databases, it is recommended to use QxEntityEditor application or to manage the database schema with an external tool provided by the SGBD (SQLite Manager for SQLite, pgAdmin for PostgreSQL, MySQL Workbench for MySQL, etc...)  <a href="#gacdaac47549d0e850cf5d6a16315efaab"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_qx_bool_8h.html#a40069a4245b458585997dadea3a86b33">qx_bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga3f941d4bf676e2762891a18f595fb4d4">qx::dao::exist</a> (T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Search if an element (or list of elements) already exists into database.  <a href="#ga3f941d4bf676e2762891a18f595fb4d4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga37648a23475371e1b83ea2082265790d">qx::dao::fetch_by_id_with_relation</a> (const QString &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch an object t (retrieve all its properties) of type T (registered into QxOrm context) mapped to a table in the database (t must have a valid id before to be fetched without error)  <a href="#ga37648a23475371e1b83ea2082265790d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga93ccebffc7a816c4bc566ed0fc8e2403">qx::dao::fetch_by_id_with_relation</a> (const QStringList &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch an object t (retrieve all its properties) of type T (registered into QxOrm context) mapped to a table in the database (t must have a valid id before to be fetched without error)  <a href="#ga93ccebffc7a816c4bc566ed0fc8e2403"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gafae6ca489fa472c6b664721845948aec">qx::dao::fetch_by_id_with_all_relation</a> (T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch an object t (retrieve all its properties and relationships) of type T (registered into QxOrm context) mapped to a table in the database (t must have a valid id before to be fetched without error)  <a href="#gafae6ca489fa472c6b664721845948aec"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gad4e90031bacdd06cf278ae3ccefa9811">qx::dao::fetch_all_with_relation</a> (const QString &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a list of objects (retrieve all elements and properties associated) of type T (container registered into QxOrm context) mapped to a table in the database.  <a href="#gad4e90031bacdd06cf278ae3ccefa9811"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga31d712c392496d5e185e2f9036254789">qx::dao::fetch_all_with_relation</a> (const QStringList &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a list of objects (retrieve all elements and properties associated) of type T (container registered into QxOrm context) mapped to a table in the database.  <a href="#ga31d712c392496d5e185e2f9036254789"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gafde0aa42be925bc394520674bbe03c01">qx::dao::fetch_all_with_all_relation</a> (T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a list of objects (retrieve all elements and properties + all relationships associated) of type T (container registered into QxOrm context) mapped to a table in the database.  <a href="#gafde0aa42be925bc394520674bbe03c01"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga2d8f0176ef1c7b675297637090c95129">qx::dao::fetch_by_query_with_relation</a> (const QString &amp;relation, const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a list of objects (retrieve all elements and properties associated) of type T (container registered into QxOrm context) mapped to a table in the database and filtered by a user SQL query.  <a href="#ga2d8f0176ef1c7b675297637090c95129"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gae49d4201f0a06aac254dc07b282d0c45">qx::dao::fetch_by_query_with_relation</a> (const QStringList &amp;relation, const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a list of objects (retrieve all elements and properties associated) of type T (container registered into QxOrm context) mapped to a table in the database and filtered by a user SQL query.  <a href="#gae49d4201f0a06aac254dc07b282d0c45"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gac9baf82921316cf054abb9126df5a81c">qx::dao::fetch_by_query_with_all_relation</a> (const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a list of objects (retrieve all elements and properties + all relationships associated) of type T (container registered into QxOrm context) mapped to a table in the database and filtered by a user SQL query.  <a href="#gac9baf82921316cf054abb9126df5a81c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga82e03bc10e1fbdc3f58f1efac252f4bc">qx::dao::insert_with_relation</a> (const QString &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element and its relationships (or a list of elements + relationships) into database.  <a href="#ga82e03bc10e1fbdc3f58f1efac252f4bc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga3631a4b5832cae2a7a684b5ecb0d75df">qx::dao::insert_with_relation</a> (const QStringList &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element and its relationships (or a list of elements + relationships) into database.  <a href="#ga3631a4b5832cae2a7a684b5ecb0d75df"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga5b15d51effdce39c2db51af2a3d6ee6c">qx::dao::insert_with_all_relation</a> (T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element and all its relationships (or a list of elements + all relationships) into database.  <a href="#ga5b15d51effdce39c2db51af2a3d6ee6c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga1ef8fc06625b53a5dd44aa629df0ec09">qx::dao::update_with_relation</a> (const QString &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an element and its relationships (or a list of elements + relationships) into database.  <a href="#ga1ef8fc06625b53a5dd44aa629df0ec09"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga9fb34aec7e865b97365c91ba20e422d2">qx::dao::update_by_query_with_relation</a> (const QString &amp;relation, const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an element and its relationships (or a list of elements + relationships) into database (adding a user SQL query to the default SQL query builded by QxOrm library)  <a href="#ga9fb34aec7e865b97365c91ba20e422d2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gaeb797148a635ed73ccc7b07e0441781c">qx::dao::update_with_relation</a> (const QStringList &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an element and its relationships (or a list of elements + relationships) into database.  <a href="#gaeb797148a635ed73ccc7b07e0441781c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gada891d9a5014953f85246082464ea885">qx::dao::update_by_query_with_relation</a> (const QStringList &amp;relation, const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an element and its relationships (or a list of elements + relationships) into database (adding a user SQL query to the default SQL query builded by QxOrm library)  <a href="#gada891d9a5014953f85246082464ea885"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga0dceedd8eb471369d44baa3081b6e255">qx::dao::update_with_all_relation</a> (T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an element and all its relationships (or a list of elements + all relationships) into database.  <a href="#ga0dceedd8eb471369d44baa3081b6e255"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga201b1897089841edc197fa2b86cf65b6">qx::dao::update_by_query_with_all_relation</a> (const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an element and all its relationships (or a list of elements + all relationships) into database (adding a user SQL query to the default SQL query builded by QxOrm library)  <a href="#ga201b1897089841edc197fa2b86cf65b6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga653fbb3a886e48bca4236ea3fe6ac865">qx::dao::save_with_relation</a> (const QString &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert (if no exist) or update (if already exist) an element and its relationships (or a list of elements + relationships) into database.  <a href="#ga653fbb3a886e48bca4236ea3fe6ac865"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga8e6cc3903f37563aa3db0cec36babfcd">qx::dao::save_with_relation</a> (const QStringList &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert (if no exist) or update (if already exist) an element and its relationships (or a list of elements + relationships) into database.  <a href="#ga8e6cc3903f37563aa3db0cec36babfcd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga8d08cafb739abd81f727ed64060cd577">qx::dao::save_with_all_relation</a> (T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert (if no exist) or update (if already exist) an element and all its relationships (or a list of elements + all relationships) into database.  <a href="#ga8d08cafb739abd81f727ed64060cd577"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gadf265ab7dd42ab831dbb94bf5aeeafd3">qx::dao::save_with_relation_recursive</a> (T &amp;t, <a class="el" href="structqx_1_1dao_1_1save__mode.html#a597b360b936ecba23b0137b14940897c">qx::dao::save_mode::e_save_mode</a> eSaveMode=qx::dao::save_mode::e_check_insert_or_update, QSqlDatabase *pDatabase=NULL, <a class="el" href="classqx_1_1_qx_sql_relation_params.html">qx::QxSqlRelationParams</a> *pRelationParams=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert (if no exist) or update (if already exist) recursively an element and all levels of relationships (or a list of elements + all levels of relationships) into database, useful to save a tree structure for example.  <a href="#gadf265ab7dd42ab831dbb94bf5aeeafd3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga2abaf5f2e6de160b099cf2ab74967244">qx::dao::fetch_by_id</a> (T &amp;t, QSqlDatabase *pDatabase=NULL, const QStringList &amp;columns=QStringList())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch an object t (retrieve all its properties) of type T (registered into QxOrm context) mapped to a table in the database (t must have a valid id before to be fetched without error)  <a href="#ga2abaf5f2e6de160b099cf2ab74967244"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gab7a00918917a06ad703a8d6887b94edb">qx::dao::fetch_all</a> (T &amp;t, QSqlDatabase *pDatabase=NULL, const QStringList &amp;columns=QStringList())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a list of objects (retrieve all elements and properties associated) of type T (container registered into QxOrm context) mapped to a table in the database.  <a href="#gab7a00918917a06ad703a8d6887b94edb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga98785915863d9487b0f3734b667a3c72">qx::dao::fetch_by_query</a> (const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL, const QStringList &amp;columns=QStringList())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a list of objects (retrieve all elements and properties associated) of type T (container registered into QxOrm context) mapped to a table in the database and filtered by a user SQL query.  <a href="#ga98785915863d9487b0f3734b667a3c72"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga690042401fc276a1929d311759b69ce2">qx::dao::update</a> (T &amp;t, QSqlDatabase *pDatabase=NULL, const QStringList &amp;columns=QStringList())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an element or a list of elements into database.  <a href="#ga690042401fc276a1929d311759b69ce2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga1bd1d32eccfb73ccd6a0e82130061fb4">qx::dao::update_by_query</a> (const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL, const QStringList &amp;columns=QStringList())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an element or a list of elements into database (adding a user SQL query to the default SQL query builded by QxOrm library)  <a href="#ga1bd1d32eccfb73ccd6a0e82130061fb4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga3419d221eac86764eb328da5a89f7fc9">qx::dao::update_optimized</a> (<a class="el" href="classqx_1_1dao_1_1ptr.html">qx::dao::ptr</a>&lt; T &gt; &amp;ptr, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update only modified fields/properties of an element or a list of elements into database (using is dirty pattern and qx::dao::ptr&lt;T&gt; smart-pointer)  <a href="#ga3419d221eac86764eb328da5a89f7fc9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gaf6b0075263b6f7f17de4ef5b58336620">qx::dao::update_optimized_by_query</a> (const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query, <a class="el" href="classqx_1_1dao_1_1ptr.html">qx::dao::ptr</a>&lt; T &gt; &amp;ptr, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update only modified fields/properties of an element or a list of elements into database (using is dirty pattern and qx::dao::ptr&lt;T&gt; smart-pointer), adding a user SQL query to the default SQL query builded by QxOrm library.  <a href="#gaf6b0075263b6f7f17de4ef5b58336620"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">QSqlError&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga095032025fbf7aee88da96479203a077">qx::dao::execute_query</a> (<a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a custom SQL query or a stored procedure, all columns that can be mapped to the instance of type T will be fetched automatically.  <a href="#ga095032025fbf7aee88da96479203a077"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gaed00d55c48be46437cd62bfea8f32aa5">qx::dao::on_before_insert</a> (T *t, <a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *dao)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback before inserting an object into database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm Trigger</a>)  <a href="#gaed00d55c48be46437cd62bfea8f32aa5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gaaaa2e9e04f61c53c6d0874930e36200c">qx::dao::on_before_update</a> (T *t, <a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *dao)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback before updating an object into database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm Trigger</a>)  <a href="#gaaaa2e9e04f61c53c6d0874930e36200c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga63dccf427753e3721e98a33b54d45e04">qx::dao::on_before_delete</a> (T *t, <a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *dao)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback before deleting an object into database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm Trigger</a>)  <a href="#ga63dccf427753e3721e98a33b54d45e04"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga8a7b2264975a9bbb1066e1e7fd04950b">qx::dao::on_before_fetch</a> (T *t, <a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *dao)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback before fetching an object from database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm Trigger</a>)  <a href="#ga8a7b2264975a9bbb1066e1e7fd04950b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gacaaa084f1ea02d01068ebf2511a31269">qx::dao::on_after_insert</a> (T *t, <a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *dao)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback after inserting an object into database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm Trigger</a>)  <a href="#gacaaa084f1ea02d01068ebf2511a31269"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga38b67d04705e32fa84e3616e2c5473b2">qx::dao::on_after_update</a> (T *t, <a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *dao)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback after updating an object into database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm Trigger</a>)  <a href="#ga38b67d04705e32fa84e3616e2c5473b2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga5e6316a02de905e470a8a2d4826a5638">qx::dao::on_after_delete</a> (T *t, <a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *dao)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback after deleting an object into database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm trigger</a>)  <a href="#ga5e6316a02de905e470a8a2d4826a5638"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#gabcd80dc690fadb52e684046cfc37912d">qx::dao::on_after_fetch</a> (T *t, <a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *dao)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback after fetching an object from database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm trigger</a>)  <a href="#gabcd80dc690fadb52e684046cfc37912d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QX_DLL_EXPORT QSqlError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga3288b4e3c6a3fa7aeac298262d3102dd">qx::dao::call_query</a> (<a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___qx_dao.html#ga3288b4e3c6a3fa7aeac298262d3102dd" title="qx::dao::call_query function can be used to call a custom SQL query or a stored procedure">qx::dao::call_query</a> function can be used to call a custom SQL query or a stored procedure  <a href="#ga3288b4e3c6a3fa7aeac298262d3102dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QX_DLL_EXPORT QSqlError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___qx_dao.html#ga3b5e1511d83800e22fd21351cef97e27">qx::dao::call_query_without_prepare</a> (<a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;query, QSqlDatabase *pDatabase=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___qx_dao.html#ga3b5e1511d83800e22fd21351cef97e27" title="qx::dao::call_query_without_prepare function can be used to call a custom SQL query or a stored proce...">qx::dao::call_query_without_prepare</a> function can be used to call a custom SQL query or a stored procedure : same as <a class="el" href="group___qx_dao.html#ga3288b4e3c6a3fa7aeac298262d3102dd" title="qx::dao::call_query function can be used to call a custom SQL query or a stored procedure">qx::dao::call_query()</a> function without calling prepare() QSqlQuery class method (can be useful to execute some specific SQL queries)  <a href="#ga3b5e1511d83800e22fd21351cef97e27"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga3288b4e3c6a3fa7aeac298262d3102dd"></a><!-- doxytag: member="qx::dao::call_query" ref="ga3288b4e3c6a3fa7aeac298262d3102dd" args="(qx::QxSqlQuery &amp;query, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QX_DLL_EXPORT QSqlError qx::dao::call_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="group___qx_dao.html#ga3288b4e3c6a3fa7aeac298262d3102dd" title="qx::dao::call_query function can be used to call a custom SQL query or a stored procedure">qx::dao::call_query</a> function can be used to call a custom SQL query or a stored procedure </p>
<p>To get an output value parameter (must be pass as <em>QSql::Out</em> or <em>QSql::InOut</em>) returned by a stored procedure, just call the following method : <em>QVariant <a class="el" href="classqx_1_1_qx_sql_query.html#a85fbf3ca9999f6be7105216f65886821">qx::QxSqlQuery::boundValue(const QString &amp; sKey) const</a>;</em>.<br/>
 To iterate over all resultset, just use the following methods :</p>
<ul>
<li><em>long <a class="el" href="classqx_1_1_qx_sql_query.html#ac6e41573565ef8b717412bbc91c3b391">qx::QxSqlQuery::getSqlResultRowCount() const</a>;</em></li>
<li><em>long <a class="el" href="classqx_1_1_qx_sql_query.html#ae204529b6d6d788ca245b1827c1fc4d2">qx::QxSqlQuery::getSqlResultColumnCount() const</a>;</em></li>
<li><em>QVariant <a class="el" href="classqx_1_1_qx_sql_query.html#add98e2485bb747dd5d7af30cf5e73b20">qx::QxSqlQuery::getSqlResultAt(long row, long column) const</a>;</em></li>
<li><em>QVariant <a class="el" href="classqx_1_1_qx_sql_query.html#ac46d1994d05be312eddcef6bc01c0b47">qx::QxSqlQuery::getSqlResultAt(long row, const QString &amp; column) const</a>;</em></li>
<li><em>QVector <a class="el" href="classqx_1_1_qx_sql_query.html#a208816ad3f9278cfc6dccd2c60ca8994">qx::QxSqlQuery::getSqlResultAllColumns() const</a>;</em></li>
<li><em>void <a class="el" href="classqx_1_1_qx_sql_query.html#a2e0495a247294ccbbaa5c949428bf8a7">qx::QxSqlQuery::dumpSqlResult()</a>;</em></li>
</ul>
<p>Here is an example of code using <em><a class="el" href="group___qx_dao.html#ga3288b4e3c6a3fa7aeac298262d3102dd" title="qx::dao::call_query function can be used to call a custom SQL query or a stored procedure">qx::dao::call_query</a></em> function : </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classqx_1_1_qx_sql_query.html" title="qx::QxSqlQuery : define a user SQL query added to default SQL query builded by QxOrm library...">qx_query</a> query(<span class="stringliteral">&quot;CALL MyStoredProc(:param1, :param2)&quot;</span>);
query.bind(<span class="stringliteral">&quot;:param1&quot;</span>, <span class="stringliteral">&quot;myValue1&quot;</span>);
query.bind(<span class="stringliteral">&quot;:param2&quot;</span>, 5024, QSql::InOut);
QSqlError daoError = <a class="code" href="group___qx_dao.html#ga3288b4e3c6a3fa7aeac298262d3102dd" title="qx::dao::call_query function can be used to call a custom SQL query or a stored procedure">qx::dao::call_query</a>(query);
QVariant vNewValue = query.boundValue(<span class="stringliteral">&quot;:param2&quot;</span>);
query.dumpSqlResult();
</pre></div> 
</div>
</div>
<a class="anchor" id="ga3b5e1511d83800e22fd21351cef97e27"></a><!-- doxytag: member="qx::dao::call_query_without_prepare" ref="ga3b5e1511d83800e22fd21351cef97e27" args="(qx::QxSqlQuery &amp;query, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QX_DLL_EXPORT QSqlError qx::dao::call_query_without_prepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="group___qx_dao.html#ga3b5e1511d83800e22fd21351cef97e27" title="qx::dao::call_query_without_prepare function can be used to call a custom SQL query or a stored proce...">qx::dao::call_query_without_prepare</a> function can be used to call a custom SQL query or a stored procedure : same as <a class="el" href="group___qx_dao.html#ga3288b4e3c6a3fa7aeac298262d3102dd" title="qx::dao::call_query function can be used to call a custom SQL query or a stored procedure">qx::dao::call_query()</a> function without calling prepare() QSqlQuery class method (can be useful to execute some specific SQL queries) </p>

</div>
</div>
<a class="anchor" id="gaf777ce33c67ea7fcd4e60b740d15f9ec"></a><!-- doxytag: member="qx::dao::count" ref="gaf777ce33c67ea7fcd4e60b740d15f9ec" args="(const qx::QxSqlQuery &amp;query=qx::QxSqlQuery(), QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long qx::dao::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em> = <code><a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of lines in the table (database) mapped to the C++ class T (registered into QxOrm context) and filtered by a user SQL query. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Define a user SQL query added to default SQL query builded by QxOrm library (optional parameter) </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter)</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="group___qx_dao.html#gaf777ce33c67ea7fcd4e60b740d15f9ec" title="Return the number of lines in the table (database) mapped to the C++ class T (registered into QxOrm c...">qx::dao::count&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>SELECT COUNT(*) FROM my_table</em> + <em>WHERE my_query...</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00097">97</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga092ef20c723a13b6250ed27153162665"></a><!-- doxytag: member="qx::dao::count" ref="ga092ef20c723a13b6250ed27153162665" args="(long &amp;lCount, const qx::QxSqlQuery &amp;query=qx::QxSqlQuery(), QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::count </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>lCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em> = <code><a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of lines in the table (database) mapped to the C++ class T (registered into QxOrm context) and filtered by a user SQL query. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lCount</td><td>Output parameter with the number of lines in the table associated to the SQL query </td></tr>
    <tr><td class="paramname">query</td><td>Define a user SQL query added to default SQL query builded by QxOrm library (optional parameter) </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter)</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="group___qx_dao.html#gaf777ce33c67ea7fcd4e60b740d15f9ec" title="Return the number of lines in the table (database) mapped to the C++ class T (registered into QxOrm c...">qx::dao::count&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>SELECT COUNT(*) FROM my_table</em> + <em>WHERE my_query...</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00111">111</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gacdaac47549d0e850cf5d6a16315efaab"></a><!-- doxytag: member="qx::dao::create_table" ref="gacdaac47549d0e850cf5d6a16315efaab" args="(QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::create_table </td>
          <td>(</td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a table into database (with all columns) mapped to a C++ class T (registered into QxOrm context) : be careful, this function can be used only with a SQLite database to create examples or prototypes; For other databases, it is recommended to use QxEntityEditor application or to manage the database schema with an external tool provided by the SGBD (SQLite Manager for SQLite, pgAdmin for PostgreSQL, MySQL Workbench for MySQL, etc...) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#gacdaac47549d0e850cf5d6a16315efaab" title="Create a table into database (with all columns) mapped to a C++ class T (registered into QxOrm contex...">qx::dao::create_table&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>CREATE TABLE my_table (my_id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, my_column_1 TEXT, my_column_2 TEXT, etc.)</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00245">245</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga959410c3e4bcc075a7c5f9c5d41bb734"></a><!-- doxytag: member="qx::dao::delete_all" ref="ga959410c3e4bcc075a7c5f9c5d41bb734" args="(QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::delete_all </td>
          <td>(</td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete all lines of a table (database) mapped to a C++ class T (registered into QxOrm context) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga959410c3e4bcc075a7c5f9c5d41bb734" title="Delete all lines of a table (database) mapped to a C++ class T (registered into QxOrm context)...">qx::dao::delete_all&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>DELETE FROM my_table</em><br/>
 <br/>
 If a soft delete behavior is defined for class T, <a class="el" href="group___qx_dao.html#ga959410c3e4bcc075a7c5f9c5d41bb734" title="Delete all lines of a table (database) mapped to a C++ class T (registered into QxOrm context)...">qx::dao::delete_all&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>UPDATE my_table SET is_deleted='1'</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00188">188</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga298e15a5e745ae43d99de9b4279aca3e"></a><!-- doxytag: member="qx::dao::delete_by_id" ref="ga298e15a5e745ae43d99de9b4279aca3e" args="(T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::delete_by_id </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a line (or list of lines) of a table (database) mapped to a C++ object of type T (registered into QxOrm context) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be deleted into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga298e15a5e745ae43d99de9b4279aca3e" title="Delete a line (or list of lines) of a table (database) mapped to a C++ object of type T (registered i...">qx::dao::delete_by_id&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>DELETE FROM my_table WHERE my_id = ?</em><br/>
 <br/>
 If a soft delete behavior is defined for class T, <a class="el" href="group___qx_dao.html#ga298e15a5e745ae43d99de9b4279aca3e" title="Delete a line (or list of lines) of a table (database) mapped to a C++ object of type T (registered i...">qx::dao::delete_by_id&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>UPDATE my_table SET is_deleted='1' WHERE my_id = ?</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00158">158</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac9f35c808cdff54ecd0c06784fffccdf"></a><!-- doxytag: member="qx::dao::delete_by_query" ref="gac9f35c808cdff54ecd0c06784fffccdf" args="(const qx::QxSqlQuery &amp;query, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::delete_by_query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete all lines of a table (database) mapped to a C++ class T (registered into QxOrm context) and filtered by a user SQL query. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Define a user SQL query added to default SQL query builded by QxOrm library </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#gac9f35c808cdff54ecd0c06784fffccdf" title="Delete all lines of a table (database) mapped to a C++ class T (registered into QxOrm context) and fi...">qx::dao::delete_by_query&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>DELETE FROM my_table</em> + <em>WHERE my_query...</em><br/>
 <br/>
 If a soft delete behavior is defined for class T, <a class="el" href="group___qx_dao.html#gac9f35c808cdff54ecd0c06784fffccdf" title="Delete all lines of a table (database) mapped to a C++ class T (registered into QxOrm context) and fi...">qx::dao::delete_by_query&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>UPDATE my_table SET is_deleted='1'</em> + <em>WHERE my_query...</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00218">218</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga075cc9ac81c4cf65fb67d3d286a1de76"></a><!-- doxytag: member="qx::dao::destroy_all" ref="ga075cc9ac81c4cf65fb67d3d286a1de76" args="(QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::destroy_all </td>
          <td>(</td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy all lines of a table (database) mapped to a C++ class T (registered into QxOrm context), even if a soft delete behavior is defined for class T. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga075cc9ac81c4cf65fb67d3d286a1de76" title="Destroy all lines of a table (database) mapped to a C++ class T (registered into QxOrm context)...">qx::dao::destroy_all&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>DELETE FROM my_table</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00201">201</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga776e2edd2da36029cddc13e9e6e366f5"></a><!-- doxytag: member="qx::dao::destroy_by_id" ref="ga776e2edd2da36029cddc13e9e6e366f5" args="(T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::destroy_by_id </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a line (or list of lines) of a table (database) mapped to a C++ object of type T (registered into QxOrm context), even if a soft delete behavior is defined for class T. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be destroyed into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga776e2edd2da36029cddc13e9e6e366f5" title="Destroy a line (or list of lines) of a table (database) mapped to a C++ object of type T (registered ...">qx::dao::destroy_by_id&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>DELETE FROM my_table WHERE my_id = ?</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00172">172</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga859152daecd5f06d8ca7442dc4b719a3"></a><!-- doxytag: member="qx::dao::destroy_by_query" ref="ga859152daecd5f06d8ca7442dc4b719a3" args="(const qx::QxSqlQuery &amp;query, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::destroy_by_query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy all lines of a table (database) mapped to a C++ class T (registered into QxOrm context) and filtered by a user SQL query, even if a soft delete behavior is defined for class T. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Define a user SQL query added to default SQL query builded by QxOrm library </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga859152daecd5f06d8ca7442dc4b719a3" title="Destroy all lines of a table (database) mapped to a C++ class T (registered into QxOrm context) and f...">qx::dao::destroy_by_query&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>DELETE FROM my_table</em> + <em>WHERE my_query...</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00232">232</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga095032025fbf7aee88da96479203a077"></a><!-- doxytag: member="qx::dao::execute_query" ref="ga095032025fbf7aee88da96479203a077" args="(qx::QxSqlQuery &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::execute_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute a custom SQL query or a stored procedure, all columns that can be mapped to the instance of type T will be fetched automatically. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Define a custom SQL query or a stored procedure to call </td></tr>
    <tr><td class="paramname">t</td><td>Instance of type T, all columns that can be mapped to this instance will be fetched automatically </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query </dd></dl>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00720">720</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3f941d4bf676e2762891a18f595fb4d4"></a><!-- doxytag: member="qx::dao::exist" ref="ga3f941d4bf676e2762891a18f595fb4d4" args="(T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_qx_bool_8h.html#a40069a4245b458585997dadea3a86b33">qx_bool</a> qx::dao::exist </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search if an element (or list of elements) already exists into database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be searched into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return true if element already exists into database; otherwise return false; if an error occurred, qx_bool object contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga3f941d4bf676e2762891a18f595fb4d4" title="Search if an element (or list of elements) already exists into database.">qx::dao::exist&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>SELECT * FROM my_table WHERE my_id = ?</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00259">259</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab7a00918917a06ad703a8d6887b94edb"></a><!-- doxytag: member="qx::dao::fetch_all" ref="gab7a00918917a06ad703a8d6887b94edb" args="(T &amp;t, QSqlDatabase *pDatabase=NULL, const QStringList &amp;columns=QStringList())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::fetch_all </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QStringList &amp;&#160;</td>
          <td class="paramname"><em>columns</em> = <code>QStringList()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a list of objects (retrieve all elements and properties associated) of type T (container registered into QxOrm context) mapped to a table in the database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Container to be fetched (retrieve all elements and properties associated); t is cleared before executing SQL query </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
    <tr><td class="paramname">columns</td><td>List of database table columns (mapped to properties of C++ class T) to be fetched (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#gab7a00918917a06ad703a8d6887b94edb" title="Fetch a list of objects (retrieve all elements and properties associated) of type T (container regist...">qx::dao::fetch_all&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>SELECT * FROM my_table</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00632">632</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafde0aa42be925bc394520674bbe03c01"></a><!-- doxytag: member="qx::dao::fetch_all_with_all_relation" ref="gafde0aa42be925bc394520674bbe03c01" args="(T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::fetch_all_with_all_relation </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a list of objects (retrieve all elements and properties + all relationships associated) of type T (container registered into QxOrm context) mapped to a table in the database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Container to be fetched (retrieve all elements and properties + all relationships associated); t is cleared before executing SQL query </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#gafde0aa42be925bc394520674bbe03c01" title="Fetch a list of objects (retrieve all elements and properties + all relationships associated) of type...">qx::dao::fetch_all_with_all_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>SELECT * FROM my_table</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00347">347</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad4e90031bacdd06cf278ae3ccefa9811"></a><!-- doxytag: member="qx::dao::fetch_all_with_relation" ref="gad4e90031bacdd06cf278ae3ccefa9811" args="(const QString &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::fetch_all_with_relation </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a list of objects (retrieve all elements and properties associated) of type T (container registered into QxOrm context) mapped to a table in the database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>List of relationships keys to be fetched (eager fetch instead of default lazy fetch for a relation) : use "|" separator to put many relationships keys into this parameter </td></tr>
    <tr><td class="paramname">t</td><td>Container to be fetched (retrieve all elements and properties associated); t is cleared before executing SQL query </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#gad4e90031bacdd06cf278ae3ccefa9811" title="Fetch a list of objects (retrieve all elements and properties associated) of type T (container regist...">qx::dao::fetch_all_with_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>SELECT * FROM my_table</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00318">318</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga31d712c392496d5e185e2f9036254789"></a><!-- doxytag: member="qx::dao::fetch_all_with_relation" ref="ga31d712c392496d5e185e2f9036254789" args="(const QStringList &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::fetch_all_with_relation </td>
          <td>(</td>
          <td class="paramtype">const QStringList &amp;&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a list of objects (retrieve all elements and properties associated) of type T (container registered into QxOrm context) mapped to a table in the database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>List of relationships keys to be fetched (eager fetch instead of default lazy fetch for a relation) </td></tr>
    <tr><td class="paramname">t</td><td>Container to be fetched (retrieve all elements and properties associated); t is cleared before executing SQL query </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#gad4e90031bacdd06cf278ae3ccefa9811" title="Fetch a list of objects (retrieve all elements and properties associated) of type T (container regist...">qx::dao::fetch_all_with_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>SELECT * FROM my_table</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00333">333</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2abaf5f2e6de160b099cf2ab74967244"></a><!-- doxytag: member="qx::dao::fetch_by_id" ref="ga2abaf5f2e6de160b099cf2ab74967244" args="(T &amp;t, QSqlDatabase *pDatabase=NULL, const QStringList &amp;columns=QStringList())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::fetch_by_id </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QStringList &amp;&#160;</td>
          <td class="paramname"><em>columns</em> = <code>QStringList()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch an object t (retrieve all its properties) of type T (registered into QxOrm context) mapped to a table in the database (t must have a valid id before to be fetched without error) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Instance (with a valid id) to be fetched (retrieve all properties from database) </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
    <tr><td class="paramname">columns</td><td>List of database table columns (mapped to properties of C++ class T) to be fetched (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga2abaf5f2e6de160b099cf2ab74967244" title="Fetch an object t (retrieve all its properties) of type T (registered into QxOrm context) mapped to a...">qx::dao::fetch_by_id&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>SELECT * FROM my_table WHERE my_id = ?</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00617">617</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafae6ca489fa472c6b664721845948aec"></a><!-- doxytag: member="qx::dao::fetch_by_id_with_all_relation" ref="gafae6ca489fa472c6b664721845948aec" args="(T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::fetch_by_id_with_all_relation </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch an object t (retrieve all its properties and relationships) of type T (registered into QxOrm context) mapped to a table in the database (t must have a valid id before to be fetched without error) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Instance (with a valid id) to be fetched (retrieve all properties and relationships from database) </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#gafae6ca489fa472c6b664721845948aec" title="Fetch an object t (retrieve all its properties and relationships) of type T (registered into QxOrm co...">qx::dao::fetch_by_id_with_all_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>SELECT * FROM my_table WHERE my_id = ?</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00303">303</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga37648a23475371e1b83ea2082265790d"></a><!-- doxytag: member="qx::dao::fetch_by_id_with_relation" ref="ga37648a23475371e1b83ea2082265790d" args="(const QString &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::fetch_by_id_with_relation </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch an object t (retrieve all its properties) of type T (registered into QxOrm context) mapped to a table in the database (t must have a valid id before to be fetched without error) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>List of relationships keys to be fetched (eager fetch instead of default lazy fetch for a relation) : use "|" separator to put many relationships keys into this parameter </td></tr>
    <tr><td class="paramname">t</td><td>Instance (with a valid id) to be fetched (retrieve all properties from database) </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga37648a23475371e1b83ea2082265790d" title="Fetch an object t (retrieve all its properties) of type T (registered into QxOrm context) mapped to a...">qx::dao::fetch_by_id_with_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>SELECT * FROM my_table WHERE my_id = ?</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00274">274</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga93ccebffc7a816c4bc566ed0fc8e2403"></a><!-- doxytag: member="qx::dao::fetch_by_id_with_relation" ref="ga93ccebffc7a816c4bc566ed0fc8e2403" args="(const QStringList &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::fetch_by_id_with_relation </td>
          <td>(</td>
          <td class="paramtype">const QStringList &amp;&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch an object t (retrieve all its properties) of type T (registered into QxOrm context) mapped to a table in the database (t must have a valid id before to be fetched without error) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>List of relationships keys to be fetched (eager fetch instead of default lazy fetch for a relation) </td></tr>
    <tr><td class="paramname">t</td><td>Instance (with a valid id) to be fetched (retrieve all properties from database) </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga37648a23475371e1b83ea2082265790d" title="Fetch an object t (retrieve all its properties) of type T (registered into QxOrm context) mapped to a...">qx::dao::fetch_by_id_with_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>SELECT * FROM my_table WHERE my_id = ?</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00289">289</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga98785915863d9487b0f3734b667a3c72"></a><!-- doxytag: member="qx::dao::fetch_by_query" ref="ga98785915863d9487b0f3734b667a3c72" args="(const qx::QxSqlQuery &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL, const QStringList &amp;columns=QStringList())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::fetch_by_query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QStringList &amp;&#160;</td>
          <td class="paramname"><em>columns</em> = <code>QStringList()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a list of objects (retrieve all elements and properties associated) of type T (container registered into QxOrm context) mapped to a table in the database and filtered by a user SQL query. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Define a user SQL query added to default SQL query builded by QxOrm library </td></tr>
    <tr><td class="paramname">t</td><td>Container to be fetched (retrieve all elements and properties associated); t is cleared before executing SQL query </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
    <tr><td class="paramname">columns</td><td>List of database table columns (mapped to properties of C++ class T) to be fetched (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga98785915863d9487b0f3734b667a3c72" title="Fetch a list of objects (retrieve all elements and properties associated) of type T (container regist...">qx::dao::fetch_by_query&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>SELECT * FROM my_table</em> + <em>WHERE my_query...</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00648">648</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac9baf82921316cf054abb9126df5a81c"></a><!-- doxytag: member="qx::dao::fetch_by_query_with_all_relation" ref="gac9baf82921316cf054abb9126df5a81c" args="(const qx::QxSqlQuery &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::fetch_by_query_with_all_relation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a list of objects (retrieve all elements and properties + all relationships associated) of type T (container registered into QxOrm context) mapped to a table in the database and filtered by a user SQL query. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Define a user SQL query added to default SQL query builded by QxOrm library </td></tr>
    <tr><td class="paramname">t</td><td>Container to be fetched (retrieve all elements and properties + all relationships associated); t is cleared before executing SQL query </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#gac9baf82921316cf054abb9126df5a81c" title="Fetch a list of objects (retrieve all elements and properties + all relationships associated) of type...">qx::dao::fetch_by_query_with_all_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>SELECT * FROM my_table</em> + <em>WHERE my_query...</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00394">394</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2d8f0176ef1c7b675297637090c95129"></a><!-- doxytag: member="qx::dao::fetch_by_query_with_relation" ref="ga2d8f0176ef1c7b675297637090c95129" args="(const QString &amp;relation, const qx::QxSqlQuery &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::fetch_by_query_with_relation </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a list of objects (retrieve all elements and properties associated) of type T (container registered into QxOrm context) mapped to a table in the database and filtered by a user SQL query. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>List of relationships keys to be fetched (eager fetch instead of default lazy fetch for a relation) : use "|" separator to put many relationships keys into this parameter </td></tr>
    <tr><td class="paramname">query</td><td>Define a user SQL query added to default SQL query builded by QxOrm library </td></tr>
    <tr><td class="paramname">t</td><td>Container to be fetched (retrieve all elements and properties associated); t is cleared before executing SQL query </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga2d8f0176ef1c7b675297637090c95129" title="Fetch a list of objects (retrieve all elements and properties associated) of type T (container regist...">qx::dao::fetch_by_query_with_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>SELECT * FROM my_table</em> + <em>WHERE my_query...</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00363">363</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae49d4201f0a06aac254dc07b282d0c45"></a><!-- doxytag: member="qx::dao::fetch_by_query_with_relation" ref="gae49d4201f0a06aac254dc07b282d0c45" args="(const QStringList &amp;relation, const qx::QxSqlQuery &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::fetch_by_query_with_relation </td>
          <td>(</td>
          <td class="paramtype">const QStringList &amp;&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a list of objects (retrieve all elements and properties associated) of type T (container registered into QxOrm context) mapped to a table in the database and filtered by a user SQL query. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>List of relationships keys to be fetched (eager fetch instead of default lazy fetch for a relation) </td></tr>
    <tr><td class="paramname">query</td><td>Define a user SQL query added to default SQL query builded by QxOrm library </td></tr>
    <tr><td class="paramname">t</td><td>Container to be fetched (retrieve all elements and properties associated); t is cleared before executing SQL query </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga2d8f0176ef1c7b675297637090c95129" title="Fetch a list of objects (retrieve all elements and properties associated) of type T (container regist...">qx::dao::fetch_by_query_with_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>SELECT * FROM my_table</em> + <em>WHERE my_query...</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00379">379</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab4400decee849f008633c52a47508995"></a><!-- doxytag: member="qx::dao::insert" ref="gab4400decee849f008633c52a47508995" args="(T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert an element or a list of elements into database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be inserted into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#gab4400decee849f008633c52a47508995" title="Insert an element or a list of elements into database.">qx::dao::insert&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>INSERT INTO my_table (my_column_1, my_column_2, etc.) VALUES (?, ?, etc.)</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00125">125</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5b15d51effdce39c2db51af2a3d6ee6c"></a><!-- doxytag: member="qx::dao::insert_with_all_relation" ref="ga5b15d51effdce39c2db51af2a3d6ee6c" args="(T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::insert_with_all_relation </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert an element and all its relationships (or a list of elements + all relationships) into database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be inserted into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga5b15d51effdce39c2db51af2a3d6ee6c" title="Insert an element and all its relationships (or a list of elements + all relationships) into database...">qx::dao::insert_with_all_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>INSERT INTO my_table (my_column_1, my_column_2, etc.) VALUES (?, ?, etc.)</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00438">438</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga82e03bc10e1fbdc3f58f1efac252f4bc"></a><!-- doxytag: member="qx::dao::insert_with_relation" ref="ga82e03bc10e1fbdc3f58f1efac252f4bc" args="(const QString &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::insert_with_relation </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert an element and its relationships (or a list of elements + relationships) into database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>List of relationships keys to be inserted in others tables of database : use "|" separator to put many relationships keys into this parameter </td></tr>
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be inserted into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga82e03bc10e1fbdc3f58f1efac252f4bc" title="Insert an element and its relationships (or a list of elements + relationships) into database...">qx::dao::insert_with_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>INSERT INTO my_table (my_column_1, my_column_2, etc.) VALUES (?, ?, etc.)</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00409">409</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3631a4b5832cae2a7a684b5ecb0d75df"></a><!-- doxytag: member="qx::dao::insert_with_relation" ref="ga3631a4b5832cae2a7a684b5ecb0d75df" args="(const QStringList &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::insert_with_relation </td>
          <td>(</td>
          <td class="paramtype">const QStringList &amp;&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert an element and its relationships (or a list of elements + relationships) into database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>List of relationships keys to be inserted in others tables of database </td></tr>
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be inserted into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga82e03bc10e1fbdc3f58f1efac252f4bc" title="Insert an element and its relationships (or a list of elements + relationships) into database...">qx::dao::insert_with_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>INSERT INTO my_table (my_column_1, my_column_2, etc.) VALUES (?, ?, etc.)</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00424">424</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5e6316a02de905e470a8a2d4826a5638"></a><!-- doxytag: member="qx::dao::on_after_delete" ref="ga5e6316a02de905e470a8a2d4826a5638" args="(T *t, qx::dao::detail::IxDao_Helper *dao)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qx::dao::on_after_delete </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *&#160;</td>
          <td class="paramname"><em>dao</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback after deleting an object into database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm trigger</a>) </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00776">776</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gabcd80dc690fadb52e684046cfc37912d"></a><!-- doxytag: member="qx::dao::on_after_fetch" ref="gabcd80dc690fadb52e684046cfc37912d" args="(T *t, qx::dao::detail::IxDao_Helper *dao)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qx::dao::on_after_fetch </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *&#160;</td>
          <td class="paramname"><em>dao</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback after fetching an object from database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm trigger</a>) </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00784">784</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gacaaa084f1ea02d01068ebf2511a31269"></a><!-- doxytag: member="qx::dao::on_after_insert" ref="gacaaa084f1ea02d01068ebf2511a31269" args="(T *t, qx::dao::detail::IxDao_Helper *dao)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qx::dao::on_after_insert </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *&#160;</td>
          <td class="paramname"><em>dao</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback after inserting an object into database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm Trigger</a>) </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00760">760</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga38b67d04705e32fa84e3616e2c5473b2"></a><!-- doxytag: member="qx::dao::on_after_update" ref="ga38b67d04705e32fa84e3616e2c5473b2" args="(T *t, qx::dao::detail::IxDao_Helper *dao)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qx::dao::on_after_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *&#160;</td>
          <td class="paramname"><em>dao</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback after updating an object into database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm Trigger</a>) </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00768">768</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga63dccf427753e3721e98a33b54d45e04"></a><!-- doxytag: member="qx::dao::on_before_delete" ref="ga63dccf427753e3721e98a33b54d45e04" args="(T *t, qx::dao::detail::IxDao_Helper *dao)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qx::dao::on_before_delete </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *&#160;</td>
          <td class="paramname"><em>dao</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback before deleting an object into database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm Trigger</a>) </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00744">744</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga8a7b2264975a9bbb1066e1e7fd04950b"></a><!-- doxytag: member="qx::dao::on_before_fetch" ref="ga8a7b2264975a9bbb1066e1e7fd04950b" args="(T *t, qx::dao::detail::IxDao_Helper *dao)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qx::dao::on_before_fetch </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *&#160;</td>
          <td class="paramname"><em>dao</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback before fetching an object from database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm Trigger</a>) </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00752">752</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaed00d55c48be46437cd62bfea8f32aa5"></a><!-- doxytag: member="qx::dao::on_before_insert" ref="gaed00d55c48be46437cd62bfea8f32aa5" args="(T *t, qx::dao::detail::IxDao_Helper *dao)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qx::dao::on_before_insert </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *&#160;</td>
          <td class="paramname"><em>dao</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback before inserting an object into database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm Trigger</a>) </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00728">728</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaaaa2e9e04f61c53c6d0874930e36200c"></a><!-- doxytag: member="qx::dao::on_before_update" ref="gaaaa2e9e04f61c53c6d0874930e36200c" args="(T *t, qx::dao::detail::IxDao_Helper *dao)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qx::dao::on_before_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a> *&#160;</td>
          <td class="paramname"><em>dao</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback before updating an object into database (<a href="http://www.qxorm.com/qxorm_en/faq.html#faq_130" target="_blank">here is an example using QxOrm Trigger</a>) </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00736">736</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga100e9d635a4720ed9512799ba0ea519b"></a><!-- doxytag: member="qx::dao::save" ref="ga100e9d635a4720ed9512799ba0ea519b" args="(T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::save </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert (if no exist) or update (if already exist) an element or a list of elements into database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be inserted (if no exist) or updated (if already exist) into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga100e9d635a4720ed9512799ba0ea519b" title="Insert (if no exist) or update (if already exist) an element or a list of elements into database...">qx::dao::save&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>INSERT INTO my_table (my_column_1, my_column_2, etc.) VALUES (?, ?, etc.)</em> <br/>
or (if already exist into database) :<br/>
 <em>UPDATE my_table SET my_column_1 = ?, my_column_2 = ?, etc.</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00141">141</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga8d08cafb739abd81f727ed64060cd577"></a><!-- doxytag: member="qx::dao::save_with_all_relation" ref="ga8d08cafb739abd81f727ed64060cd577" args="(T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::save_with_all_relation </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert (if no exist) or update (if already exist) an element and all its relationships (or a list of elements + all relationships) into database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be inserted (if no exist) or updated (if already exist) into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga8d08cafb739abd81f727ed64060cd577" title="Insert (if no exist) or update (if already exist) an element and all its relationships (or a list of ...">qx::dao::save_with_all_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>INSERT INTO my_table (my_column_1, my_column_2, etc.) VALUES (?, ?, etc.)</em> <br/>
or (if already exist into database) :<br/>
 <em>UPDATE my_table SET my_column_1 = ?, my_column_2 = ?, etc.</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00579">579</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga653fbb3a886e48bca4236ea3fe6ac865"></a><!-- doxytag: member="qx::dao::save_with_relation" ref="ga653fbb3a886e48bca4236ea3fe6ac865" args="(const QString &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::save_with_relation </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert (if no exist) or update (if already exist) an element and its relationships (or a list of elements + relationships) into database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>List of relationships keys to be inserted or updated in others tables of database : use "|" separator to put many relationships keys into this parameter </td></tr>
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be inserted (if no exist) or updated (if already exist) into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga653fbb3a886e48bca4236ea3fe6ac865" title="Insert (if no exist) or update (if already exist) an element and its relationships (or a list of elem...">qx::dao::save_with_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>INSERT INTO my_table (my_column_1, my_column_2, etc.) VALUES (?, ?, etc.)</em> <br/>
or (if already exist into database) :<br/>
 <em>UPDATE my_table SET my_column_1 = ?, my_column_2 = ?, etc.</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00546">546</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga8e6cc3903f37563aa3db0cec36babfcd"></a><!-- doxytag: member="qx::dao::save_with_relation" ref="ga8e6cc3903f37563aa3db0cec36babfcd" args="(const QStringList &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::save_with_relation </td>
          <td>(</td>
          <td class="paramtype">const QStringList &amp;&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert (if no exist) or update (if already exist) an element and its relationships (or a list of elements + relationships) into database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>List of relationships keys to be inserted or updated in others tables of database </td></tr>
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be inserted (if no exist) or updated (if already exist) into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga653fbb3a886e48bca4236ea3fe6ac865" title="Insert (if no exist) or update (if already exist) an element and its relationships (or a list of elem...">qx::dao::save_with_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>INSERT INTO my_table (my_column_1, my_column_2, etc.) VALUES (?, ?, etc.)</em> <br/>
or (if already exist into database) :<br/>
 <em>UPDATE my_table SET my_column_1 = ?, my_column_2 = ?, etc.</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00563">563</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gadf265ab7dd42ab831dbb94bf5aeeafd3"></a><!-- doxytag: member="qx::dao::save_with_relation_recursive" ref="gadf265ab7dd42ab831dbb94bf5aeeafd3" args="(T &amp;t, qx::dao::save_mode::e_save_mode eSaveMode=qx::dao::save_mode::e_check_insert_or_update, QSqlDatabase *pDatabase=NULL, qx::QxSqlRelationParams *pRelationParams=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::save_with_relation_recursive </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structqx_1_1dao_1_1save__mode.html#a597b360b936ecba23b0137b14940897c">qx::dao::save_mode::e_save_mode</a>&#160;</td>
          <td class="paramname"><em>eSaveMode</em> = <code>qx::dao::save_mode::e_check_insert_or_update</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classqx_1_1_qx_sql_relation_params.html">qx::QxSqlRelationParams</a> *&#160;</td>
          <td class="paramname"><em>pRelationParams</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert (if no exist) or update (if already exist) recursively an element and all levels of relationships (or a list of elements + all levels of relationships) into database, useful to save a tree structure for example. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be inserted (if no exist) or updated (if already exist) into database </td></tr>
    <tr><td class="paramname">eSaveMode</td><td>To improve performance, use this parameter to indicate if you just want to insert or update all elements in database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
    <tr><td class="paramname">pRelationParams</td><td>Keep this parameter as NULL, it is used internally by QxOrm library to iterate over each level of relationship </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#gadf265ab7dd42ab831dbb94bf5aeeafd3" title="Insert (if no exist) or update (if already exist) recursively an element and all levels of relationsh...">qx::dao::save_with_relation_recursive&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>INSERT INTO my_table (my_column_1, my_column_2, etc.) VALUES (?, ?, etc.)</em> <br/>
or (if already exist into database) :<br/>
 <em>UPDATE my_table SET my_column_1 = ?, my_column_2 = ?, etc.</em><br/>
 <br/>
 <b>Note :</b> to improve performance, and if you know that you are just inserting or updating items in database, you can use the parameter <em>eSaveMode</em> :<br/>
</p>
<ul>
<li><em><a class="el" href="structqx_1_1dao_1_1save__mode.html#a597b360b936ecba23b0137b14940897ca5a854540ed438d33cb50160f25c7ac2b">qx::dao::save_mode::e_check_insert_or_update</a></em> : check before saving if item already exists in database ;<br/>
</li>
<li><em><a class="el" href="structqx_1_1dao_1_1save__mode.html#a597b360b936ecba23b0137b14940897ca9ee7610a9cd93fe081f8679a0744f2fe">qx::dao::save_mode::e_insert_only</a></em> : only insert items in database (use only 1 SQL query to insert collection of items) ;<br/>
</li>
<li><em><a class="el" href="structqx_1_1dao_1_1save__mode.html#a597b360b936ecba23b0137b14940897ca610a0bcee253b3cfe15304f93f1cfdd2">qx::dao::save_mode::e_update_only</a></em> : only update items in database (use only 1 SQL query to update collection of items). </li>
</ul>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00602">602</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga690042401fc276a1929d311759b69ce2"></a><!-- doxytag: member="qx::dao::update" ref="ga690042401fc276a1929d311759b69ce2" args="(T &amp;t, QSqlDatabase *pDatabase=NULL, const QStringList &amp;columns=QStringList())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::update </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QStringList &amp;&#160;</td>
          <td class="paramname"><em>columns</em> = <code>QStringList()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update an element or a list of elements into database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be updated into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
    <tr><td class="paramname">columns</td><td>List of database table columns (mapped to properties of C++ class T) to be updated (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga690042401fc276a1929d311759b69ce2" title="Update an element or a list of elements into database.">qx::dao::update&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>UPDATE my_table SET my_column_1 = ?, my_column_2 = ?, etc.</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00663">663</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1bd1d32eccfb73ccd6a0e82130061fb4"></a><!-- doxytag: member="qx::dao::update_by_query" ref="ga1bd1d32eccfb73ccd6a0e82130061fb4" args="(const qx::QxSqlQuery &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL, const QStringList &amp;columns=QStringList())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::update_by_query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QStringList &amp;&#160;</td>
          <td class="paramname"><em>columns</em> = <code>QStringList()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update an element or a list of elements into database (adding a user SQL query to the default SQL query builded by QxOrm library) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Define a user SQL query added to default SQL query builded by QxOrm library </td></tr>
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be updated into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
    <tr><td class="paramname">columns</td><td>List of database table columns (mapped to properties of C++ class T) to be updated (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga1bd1d32eccfb73ccd6a0e82130061fb4" title="Update an element or a list of elements into database (adding a user SQL query to the default SQL que...">qx::dao::update_by_query&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>UPDATE my_table SET my_column_1 = ?, my_column_2 = ?, etc.</em> + <em>WHERE my_query...</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00679">679</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga201b1897089841edc197fa2b86cf65b6"></a><!-- doxytag: member="qx::dao::update_by_query_with_all_relation" ref="ga201b1897089841edc197fa2b86cf65b6" args="(const qx::QxSqlQuery &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::update_by_query_with_all_relation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update an element and all its relationships (or a list of elements + all relationships) into database (adding a user SQL query to the default SQL query builded by QxOrm library) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Define a user SQL query added to default SQL query builded by QxOrm library </td></tr>
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be updated into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga201b1897089841edc197fa2b86cf65b6" title="Update an element and all its relationships (or a list of elements + all relationships) into database...">qx::dao::update_by_query_with_all_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>UPDATE my_table SET my_column_1 = ?, my_column_2 = ?, etc.</em> + <em>WHERE my_query...</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00529">529</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9fb34aec7e865b97365c91ba20e422d2"></a><!-- doxytag: member="qx::dao::update_by_query_with_relation" ref="ga9fb34aec7e865b97365c91ba20e422d2" args="(const QString &amp;relation, const qx::QxSqlQuery &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::update_by_query_with_relation </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update an element and its relationships (or a list of elements + relationships) into database (adding a user SQL query to the default SQL query builded by QxOrm library) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>List of relationships keys to be updated in others tables of database : use "|" separator to put many relationships keys into this parameter </td></tr>
    <tr><td class="paramname">query</td><td>Define a user SQL query added to default SQL query builded by QxOrm library </td></tr>
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be updated into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga9fb34aec7e865b97365c91ba20e422d2" title="Update an element and its relationships (or a list of elements + relationships) into database (adding...">qx::dao::update_by_query_with_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>UPDATE my_table SET my_column_1 = ?, my_column_2 = ?, etc.</em> + <em>WHERE my_query...</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00469">469</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gada891d9a5014953f85246082464ea885"></a><!-- doxytag: member="qx::dao::update_by_query_with_relation" ref="gada891d9a5014953f85246082464ea885" args="(const QStringList &amp;relation, const qx::QxSqlQuery &amp;query, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::update_by_query_with_relation </td>
          <td>(</td>
          <td class="paramtype">const QStringList &amp;&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update an element and its relationships (or a list of elements + relationships) into database (adding a user SQL query to the default SQL query builded by QxOrm library) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>List of relationships keys to be updated in others tables of database </td></tr>
    <tr><td class="paramname">query</td><td>Define a user SQL query added to default SQL query builded by QxOrm library </td></tr>
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be updated into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga9fb34aec7e865b97365c91ba20e422d2" title="Update an element and its relationships (or a list of elements + relationships) into database (adding...">qx::dao::update_by_query_with_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>UPDATE my_table SET my_column_1 = ?, my_column_2 = ?, etc.</em> + <em>WHERE my_query...</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00500">500</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3419d221eac86764eb328da5a89f7fc9"></a><!-- doxytag: member="qx::dao::update_optimized" ref="ga3419d221eac86764eb328da5a89f7fc9" args="(qx::dao::ptr&lt; T &gt; &amp;ptr, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::update_optimized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqx_1_1dao_1_1ptr.html">qx::dao::ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update only modified fields/properties of an element or a list of elements into database (using is dirty pattern and qx::dao::ptr&lt;T&gt; smart-pointer) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Element (or list of elements) to be updated into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga3419d221eac86764eb328da5a89f7fc9" title="Update only modified fields/properties of an element or a list of elements into database (using is di...">qx::dao::update_optimized&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>UPDATE my_table SET my_column_1 = ?, my_column_2 = ?, etc.</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00693">693</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf6b0075263b6f7f17de4ef5b58336620"></a><!-- doxytag: member="qx::dao::update_optimized_by_query" ref="gaf6b0075263b6f7f17de4ef5b58336620" args="(const qx::QxSqlQuery &amp;query, qx::dao::ptr&lt; T &gt; &amp;ptr, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::update_optimized_by_query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classqx_1_1dao_1_1ptr.html">qx::dao::ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update only modified fields/properties of an element or a list of elements into database (using is dirty pattern and qx::dao::ptr&lt;T&gt; smart-pointer), adding a user SQL query to the default SQL query builded by QxOrm library. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Define a user SQL query added to default SQL query builded by QxOrm library </td></tr>
    <tr><td class="paramname">ptr</td><td>Element (or list of elements) to be updated into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#gaf6b0075263b6f7f17de4ef5b58336620" title="Update only modified fields/properties of an element or a list of elements into database (using is di...">qx::dao::update_optimized_by_query&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>UPDATE my_table SET my_column_1 = ?, my_column_2 = ?, etc.</em> + <em>WHERE my_query...</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00708">708</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0dceedd8eb471369d44baa3081b6e255"></a><!-- doxytag: member="qx::dao::update_with_all_relation" ref="ga0dceedd8eb471369d44baa3081b6e255" args="(T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::update_with_all_relation </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update an element and all its relationships (or a list of elements + all relationships) into database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be updated into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga0dceedd8eb471369d44baa3081b6e255" title="Update an element and all its relationships (or a list of elements + all relationships) into database...">qx::dao::update_with_all_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>UPDATE my_table SET my_column_1 = ?, my_column_2 = ?, etc.</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00514">514</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ef8fc06625b53a5dd44aa629df0ec09"></a><!-- doxytag: member="qx::dao::update_with_relation" ref="ga1ef8fc06625b53a5dd44aa629df0ec09" args="(const QString &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::update_with_relation </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update an element and its relationships (or a list of elements + relationships) into database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>List of relationships keys to be updated in others tables of database : use "|" separator to put many relationships keys into this parameter </td></tr>
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be updated into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga1ef8fc06625b53a5dd44aa629df0ec09" title="Update an element and its relationships (or a list of elements + relationships) into database...">qx::dao::update_with_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>UPDATE my_table SET my_column_1 = ?, my_column_2 = ?, etc.</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00453">453</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaeb797148a635ed73ccc7b07e0441781c"></a><!-- doxytag: member="qx::dao::update_with_relation" ref="gaeb797148a635ed73ccc7b07e0441781c" args="(const QStringList &amp;relation, T &amp;t, QSqlDatabase *pDatabase=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">QSqlError qx::dao::update_with_relation </td>
          <td>(</td>
          <td class="paramtype">const QStringList &amp;&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSqlDatabase *&#160;</td>
          <td class="paramname"><em>pDatabase</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update an element and its relationships (or a list of elements + relationships) into database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>List of relationships keys to be updated in others tables of database </td></tr>
    <tr><td class="paramname">t</td><td>Element (or list of elements) to be updated into database </td></tr>
    <tr><td class="paramname">pDatabase</td><td>Connection to database (you can manage your own connection pool for example, you can also define a transaction, etc.); if NULL, a valid connection for the current thread is provided by <a class="el" href="classqx_1_1_qx_sql_database.html" title="qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by t...">qx::QxSqlDatabase</a> singleton class (optional parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty QSqlError object (from Qt library) if no error occurred; otherwise QSqlError contains a description of database error executing SQL query</dd></dl>
<p><a class="el" href="group___qx_dao.html#ga1ef8fc06625b53a5dd44aa629df0ec09" title="Update an element and its relationships (or a list of elements + relationships) into database...">qx::dao::update_with_relation&lt;T&gt;()</a> execute following SQL query :<br/>
 <em>UPDATE my_table SET my_column_1 = ?, my_column_2 = ?, etc.</em> </p>

<p>Definition at line <a class="el" href="_qx_dao_8h_source.html#l00484">484</a> of file <a class="el" href="_qx_dao_8h_source.html">QxDao.h</a>.</p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Sun Dec 11 2016 13:41:10 for QxOrm by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
